---
title: "Make Location Filtered GPS Data" 
author: "Claire Punturieri"
date: "`r lubridate::today()`"
format: 
  html: 
    embed-resources: true
    toc: true 
    toc_depth: 4
editor_options: 
  chunk_output_type: console
---   

### Notes

Need to circle back to discuss filtering.

What should we do if someone doesn't have an active point at a given location? Are we interested in using their last known point?

### Setup

```{r}
#| message: false

options(conflicts.policy = "depends.ok")

library(tidyverse)
library(future)

devtools::source_url("https://github.com/jjcurtin/lab_support/blob/main/format_path.R?raw=true")

path_processed <- format_path("studydata/risk/data_processed/shared")
path_gps <- format_path("studydata/risk/data_processed/gps")
path_terrain <- format_path("studydata/risk/data_processed/terrain")

dist_max <- 0.031   # only use context if places are within 50 meters (0.031 miles)
```

### Read in files

```{r}
lapses <- read_csv(here::here(path_terrain, "lapses.csv"),
                show_col_types = FALSE) |>
  mutate(lapse_start = with_tz(lapse_start, tz = "America/Chicago"),
         lapse_end = with_tz(lapse_end, tz = "America/Chicago"),
         lapse_id = 1:n()) |> 
  glimpse()

lapses <- lapses |>
  group_by(subid) |> 
  mutate(lapse_total = n(),
         lapse_no = 1:n()) |> 
  ungroup()

context <- read_csv(here::here(path_gps, "gps_enriched.csv.xz"), show_col_types = FALSE) |>
  # variable conversions
  mutate(time = with_tz(time, tz = "America/Chicago"),
         dist = dist / 1609.344,
         duration = duration / 60,
         speed = dist / duration,
         dist_context = dist_context / 1609.344) |>
    mutate(duration = if_else(dist > 0.01 & duration == 0, NA_real_, duration),
         duration = if_else(speed > 100, NA_real_, duration),
         duration = if_else(duration > 2 & dist > 0.31, NA_real_, duration),
         duration = if_else(duration > 24, 24, duration),
         known_loc = if_else(dist_context <= dist_max & speed <= 4, TRUE, FALSE),
         known_loc = if_else(is.na(known_loc), FALSE, known_loc)) |> 
  rename(dttm_obs = time) |> 
  select(subid, lat, lon, dttm_obs, dist, duration, context_id, known_loc,
         lat_context, lon_context, dist_context, risk)

# need to think more if we want to filter things out
context <- context |> drop_na(duration) |> select(-dist, -duration)
```

### Filter subjects

Filter down to subjects who had a lapse.
```{r}
subids_lapses <- lapses |>  
  pull(subid) |>  
  unique()

context <- context |>
  filter(subid %in% subids_lapses)
```

Count number of subjects.
```{r}
lapses |>  
  distinct(subid) |> 
  nrow()
```

Count number of lapses.
```{r}
lapses |> 
  nrow()
```

### Isolate to lapse events

This function takes in the gps and lapse information for an individual and filters gps data down to only gps points collected during a lapse period.
```{r}
lapse_filter <- function(id, context, lapses) {
  
  context_tmp <- context |> filter(subid == id)
  
  lapses_tmp <- lapses |> filter(subid == id)
  
  context_tmp <- context_tmp |> 
    rowwise() |> 
    mutate(
      matched_lapse = list(lapses_tmp |>  
                            filter(dttm_obs >= lapse_start & dttm_obs <= lapse_end) |> 
                            select(lapse_start, lapse_end, lapse_id, lapse_no, lapse_total)
                           )
    ) |> 
    unnest(cols = c(matched_lapse))

  if (nrow(context_tmp) == 0) {
    print("Lapse ID has no GPS retained!")
  }
  
  return(context_tmp)
}
```

```{r}
future::plan(multisession, workers = parallel::detectCores(logical = FALSE))

context_filtered <- context$subid |>
  unique() |>
  furrr::future_map(\(subid) lapse_filter(id = subid, context, lapses)) |>  
  list_rbind() |> 
  select(subid, lat, lon, dttm_obs, lapse_start, lapse_end, lapse_id, lapse_no, lapse_total, everything())
```

### Intermediate EDA

Identify number of subjects who have been retained (i.e., have GPS points that occur during a lapse event).
```{r}
nsub <- context |>
  distinct(subid) |>
  nrow()

nsub_filtered <- context_filtered |> 
  distinct(subid) |> 
  nrow()
```

> Started with: `r nsub`
Ended with: `r nsub_filtered`

Identify what subjects are missing from context_filtered and their lapses.
```{r}
subids_filter <- context_filtered |>  
  pull(subid) |>  
  unique()

missing_subjects <- context |>
  filter(!subid %in% subids_filter) |> 
  pull(subid) |> 
  unique()

missing_lapses <- lapses |> 
  filter(subid %in% missing_subjects) |> 
  pull(lapse_id) |> 
  unique()
```

>We are losing subjects: `r missing_subjects`
We are missing lapse ids: `r missing_lapses`

Identify number of unique lapse identifiers that have been retained.
```{r}
nlapse <- lapses |> 
  nrow()

nlapse_filtered <- context_filtered |> 
  distinct(lapse_id) |> 
  nrow()
```

>Started with `r nlapse` lapses
Ended with `r nlapse_filtered` lapses

Identify number of observations at which an individual is at a known location.
```{r}
table(context_filtered$known_loc)
```

Of known locations, display relative risk levels.
```{r}
context_filt_known <- context_filtered |>
  filter(known_loc == TRUE)

table(context_filt_known$risk)
```

Of known locations, how do relative risk levels vary **outside** of lapse periods?
```{r}
dttm_filt <- context_filtered |>  
  pull(dttm_obs) |>  
  unique()

context_nolapse <- context |>
  filter(!dttm_obs %in% dttm_filt) |> 
  filter(known_loc == TRUE)

table(context_nolapse$risk)
```

Of known locations, how many observations are missing a risk level?
```{r}
sum(is.na(context_filt_known$risk))
```

### Filter to first latitude and longitude pair

```{r}
context_first <- context_filtered |> 
  group_by(lapse_id) |> 
  slice_head(n = 1)
```

### Identify individuals outside of Madison, WI

Reverse-geocode lat/lon pairs to determine location at time of sampling.
```{r}
context_rev <- context_first |> tidygeocoder::reverse_geocode(lat = lat, long = lon,
                                                       address = address_found,
                                                       full_results = TRUE)
```

View gps observations by country.
```{r}
table(context_rev$country)
```

View gps observations by state.
```{r}
table(context_rev$state)
```

View gps observations by county.
```{r}
context_rev_wi <- context_rev |> filter(state == "Wisconsin")

table(context_rev_wi$county)
```

View gps observations by city.
```{r}
table(context_rev_wi$city)
```

Next, we filter down to observations **only within Dane County**.
```{r}
context_final <- context_rev |> filter(county == "Dane County")
```

### Final EDA

Identify number of observations at which an individual is at a known location.
```{r}
table(context_final$known_loc)
```

Of known locations, display relative risk levels.
```{r}
context_final_known <- context_final |>
  filter(known_loc == TRUE)

table(context_final_known$risk)
```

Of known locations, how many observations are missing a risk level?
```{r}
sum(is.na(context_final_known$risk))
```

How many observations are unique?
```{r}
context_final |>
  mutate(latlon = paste0(lat, " ", lon)) |>
  distinct(latlon) |>
  nrow()
```

### Save out file

```{r}
context_final |>
  select(subid:risk, city, county, state) |> 
  write_csv(here::here(path_terrain, "gps_terrain.csv"))
```


